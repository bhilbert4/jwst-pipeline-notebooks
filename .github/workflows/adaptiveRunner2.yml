name: Resource Adaptive Jupyter Notebook Processing

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      python-version:
        description: 'Python version to use for notebook execution'
        required: true
        type: string
  workflow_call:
    inputs:
      python-version:
        description: 'Python version to use for notebook execution'
        required: true
        type: string

env:
  MEMORY_THRESHOLD: 80  # Percentage
  CPU_THRESHOLD: 80     # Percentage

jobs:
  discover-notebooks:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Find Jupyter Notebooks
        id: set-matrix
        run: |
          # Find all .ipynb files recursively under notebooks/
          NOTEBOOKS=$(find notebooks/ -type f -name "*.ipynb" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          # Format as JSON matrix
          MATRIX_JSON=$(echo "$NOTEBOOKS" | jq -c '{args: .}')
          
          # Set output - escape newlines and quotes properly
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  process-notebooks:
    needs: discover-notebooks
    strategy:
      matrix: ${{ fromJson(needs.discover-notebooks.outputs.matrix) }}
      fail-fast: false

    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ github.event.inputs.python-version || '3.x' }}

      - name: Install Jupyter and Monitoring Tools
        run: |
          pip install jupyter nbconvert psutil

      - name: Install Notebook Requirements
        run: |
          NOTEBOOK_DIR=$(dirname "${{ matrix.args }}")
          REQUIREMENTS="$NOTEBOOK_DIR/requirements.txt"
          if [ -f "$REQUIREMENTS" ]; then
            pip install -r "$REQUIREMENTS"
          else
            echo "No requirements.txt found in $NOTEBOOK_DIR, skipping dependency installation"
          fi

      - name: Run Notebook with Resource Monitoring (Standard)
        id: standard-run
        continue-on-error: true
        run: |
          # Create a monitoring script
          cat << 'EOF' > monitor_resources.py
          import psutil
          import os
          import sys
          import time

          def monitor_resources(pid, threshold_mem, threshold_cpu, interval=1):
              process = psutil.Process(pid)
              max_mem = 0
              max_cpu = 0
              while psutil.pid_exists(pid):
                  try:
                      mem = process.memory_percent()
                      cpu = process.cpu_percent(interval=interval)
                      max_mem = max(max_mem, mem)
                      max_cpu = max(max_cpu, cpu)
                      if mem > threshold_mem or cpu > threshold_cpu:
                          print(f"Resource exceeded: Memory {mem:.1f}% (max {max_mem:.1f}%) > {threshold_mem}%, CPU {cpu:.1f}% (max {max_cpu:.1f}%) > {threshold_cpu}%")
                          sys.exit(1)
                      time.sleep(interval)
                  except psutil.NoSuchProcess:
                      break
              print(f"Max resources used: Memory {max_mem:.1f}%, CPU {max_cpu:.1f}%")
              return max_mem, max_cpu

          if __name__ == "__main__":
              pid = int(sys.argv[1])
              threshold_mem = float(sys.argv[2])
              threshold_cpu = float(sys.argv[3])
              monitor_resources(pid, threshold_mem, threshold_cpu)
          EOF

          # Run notebook in background and monitor resources
          jupyter nbconvert --to notebook --execute "${{ matrix.args }}" &
          NOTEBOOK_PID=$!
          
          # Start monitoring
          python monitor_resources.py $NOTEBOOK_PID ${MEMORY_THRESHOLD} ${CPU_THRESHOLD}
          
          # Wait for notebook process to complete and get its exit code
          wait $NOTEBOOK_PID
          NOTEBOOK_EXIT_CODE=$?
          
          # If notebook failed for reasons other than resources, fail the step
          if [ $NOTEBOOK_EXIT_CODE -ne 0 ]; then
            echo "Notebook execution failed with exit code $NOTEBOOK_EXIT_CODE"
            exit 1
          fi

      - name: Clean and Re-checkout (Before 16GB)
        if: steps.standard-run.outcome == 'failure'
        runs-on: ubuntu-latest
        steps:
          - name: Determine notebook directory
            id: get-dir
            run: |
              NOTEBOOK_DIR=$(dirname "${{ matrix.args }}")
              echo "notebook_dir=$NOTEBOOK_DIR" >> $GITHUB_OUTPUT
          - name: Clean notebook directory
            run: |
              rm -rf "${{ steps.get-dir.outputs.notebook_dir }}"/*
          - name: Re-checkout repository
            uses: actions/checkout@v3

      - name: Run Notebook (16GB Runner Group)
        if: steps.standard-run.outcome == 'failure'
        runs-on: 
          group: jwst-pipeline-notebooks-16gb
        id: medium-run
        continue-on-error: true
        steps:
          - name: Checkout code
            uses: actions/checkout@v3
          - name: Setup Python
            uses: actions/setup-python@v4
            with:
              python-version: ${{ github.event.inputs.python-version || '3.x' }}
          - name: Install Jupyter and Monitoring Tools
            run: |
              pip install jupyter nbconvert psutil
          - name: Install Notebook Requirements
            run: |
              NOTEBOOK_DIR=$(dirname "${{ matrix.args }}")
              REQUIREMENTS="$NOTEBOOK_DIR/requirements.txt"
              if [ -f "$REQUIREMENTS" ]; then
                pip install -r "$REQUIREMENTS"
              else
                echo "No requirements.txt found in $NOTEBOOK_DIR, skipping dependency installation"
              fi
          - name: Run on 16GB runner with Resource Monitoring
            run: |
              # Create monitoring script (same as above)
              cat << 'EOF' > monitor_resources.py
              import psutil
              import os
              import sys
              import time

              def monitor_resources(pid, threshold_mem, threshold_cpu, interval=1):
                  process = psutil.Process(pid)
                  max_mem = 0
                  max_cpu = 0
                  while psutil.pid_exists(pid):
                      try:
                          mem = process.memory_percent()
                          cpu = process.cpu_percent(interval=interval)
                          max_mem = max(max_mem, mem)
                          max_cpu = max(max_cpu, cpu)
                          if mem > threshold_mem or cpu > threshold_cpu:
                              print(f"Resource exceeded: Memory {mem:.1f}% (max {max_mem:.1f}%) > {threshold_mem}%, CPU {cpu:.1f}% (max {max_cpu:.1f}%) > {threshold_cpu}%")
                              sys.exit(1)
                          time.sleep(interval)
                      except psutil.NoSuchProcess:
                          break
                  print(f"Max resources used: Memory {max_mem:.1f}%, CPU {max_cpu:.1f}%")
                  return max_mem, max_cpu

              if __name__ == "__main__":
                  pid = int(sys.argv[1])
                  threshold_mem = float(sys.argv[2])
                  threshold_cpu = float(sys.argv[3])
                  monitor_resources(pid, threshold_mem, threshold_cpu)
              EOF

              # Run notebook in background and monitor resources
              jupyter nbconvert --to notebook --execute "${{ matrix.args }}" &
              NOTEBOOK_PID=$!
              
              # Start monitoring
              python monitor_resources.py $NOTEBOOK_PID ${MEMORY_THRESHOLD} ${CPU_THRESHOLD}
              
              # Wait for notebook process to complete and get its exit code
              wait $NOTEBOOK_PID
              NOTEBOOK_EXIT_CODE=$?
              
              # If notebook failed for reasons other than resources, fail the step
              if [ $NOTEBOOK_EXIT_CODE -ne 0 ]; then
                echo "Notebook execution failed with exit code $NOTEBOOK_EXIT_CODE"
                exit 1
              fi

      - name: Clean and Re-checkout (Before 32GB)
        if: steps.medium-run.outcome == 'failure'
        runs-on: ubuntu-latest
        steps:
          - name: Determine notebook directory
            id: get-dir
            run: |
              NOTEBOOK_DIR=$(dirname "${{ matrix.args }}")
              echo "notebook_dir=$NOTEBOOK_DIR" >> $GITHUB_OUTPUT
          - name: Clean notebook directory
            run: |
              rm -rf "${{ steps.get-dir.outputs.notebook_dir }}"/*
          - name: Re-checkout repository
            uses: actions/checkout@v3

      - name: Run Notebook (32GB Runner Group)
        if: steps.medium-run.outcome == 'failure'
        runs-on: 
          group: jwst-pipeline-notebooks-32gb
        id: large-run
        continue-on-error: true
        steps:
          - name: Checkout code
            uses: actions/checkout@v3
          - name: Setup Python
            uses: actions/setup-python@v4
            with:
              python-version: ${{ github.event.inputs.python-version || '3.x' }}
          - name: Install Jupyter and Monitoring Tools
            run: |
              pip install jupyter nbconvert psutil
          - name: Install Notebook Requirements
            run: |
              NOTEBOOK_DIR=$(dirname "${{ matrix.args }}")
              REQUIREMENTS="$NOTEBOOK_DIR/requirements.txt"
              if [ -f "$REQUIREMENTS" ]; then
                pip install -r "$REQUIREMENTS"
              else
                echo "No requirements.txt found in $NOTEBOOK_DIR, skipping dependency installation"
              fi
          - name: Run on 32GB runner with Resource Monitoring
            run: |
              # Create monitoring script (same as above)
              cat << 'EOF' > monitor_resources.py
              import psutil
              import os
              import sys
              import time

              def monitor_resources(pid, threshold_mem, threshold_cpu, interval=1):
                  process = psutil.Process(pid)
                  max_mem = 0
                  max_cpu = 0
                  while psutil.pid_exists(pid):
                      try:
                          mem = process.memory_percent()
                          cpu = process.cpu_percent(interval=interval)
                          max_mem = max(max_mem, mem)
                          max_cpu = max(max_cpu, cpu)
                          if mem > threshold_mem or cpu > threshold_cpu:
                              print(f"Resource exceeded: Memory {mem:.1f}% (max {max_mem:.1f}%) > {threshold_mem}%, CPU {cpu:.1f}% (max {max_cpu:.1f}%) > {threshold_cpu}%")
                              sys.exit(1)
                          time.sleep(interval)
                      except psutil.NoSuchProcess:
                          break
                  print(f"Max resources used: Memory {max_mem:.1f}%, CPU {max_cpu:.1f}%")
                  return max_mem, max_cpu

              if __name__ == "__main__":
                  pid = int(sys.argv[1])
                  threshold_mem = float(sys.argv[2])
                  threshold_cpu = float(sys.argv[3])
                  monitor_resources(pid, threshold_mem, threshold_cpu)
              EOF

              # Run notebook in background and monitor resources
              jupyter nbconvert --to notebook --execute "${{ matrix.args }}" &
              NOTEBOOK_PID=$!
              
              # Start monitoring
              python monitor_resources.py $NOTEBOOK_PID ${MEMORY_THRESHOLD} ${CPU_THRESHOLD}
              
              # Wait for notebook process to complete and get its exit code
              wait $NOTEBOOK_PID
              NOTEBOOK_EXIT_CODE=$?
              
              # If notebook failed for reasons other than resources, fail the step
              if [ $NOTEBOOK_EXIT_CODE -ne 0 ]; then
                echo "Notebook execution failed with exit code $NOTEBOOK_EXIT_CODE"
                exit 1
              fi

      - name: Fail if all attempts unsuccessful
        if: steps.standard-run.outcome == 'failure' && steps.medium-run.outcome == 'failure' && steps.large-run.outcome == 'failure'
        run: |
          echo "Notebook processing failed on all runner sizes for: ${{ matrix.args }}"
          exit 1
